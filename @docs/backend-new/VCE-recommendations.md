Okay, let's break down those tasks from the @docs/backend-new/oracle-implementation-enhancement-plan.md and discuss their relation to convex/prices.ts and the potential impact of the suggested libraries.
Analysis of VCE Tasks:
VCE-214: Implement weight-based volatility model logic based on option duration (placeholder)
What it is: This task involves creating logic where the specific volatility value used (e.g., in premium calculation) isn't fixed but is derived based on the duration of the option being considered. For instance, a short-term option might use the 30-day volatility, while a long-term option might use a blend of 180-day and 360-day volatilities, or perhaps a weighted average.
Relation to prices.ts: This task likely doesn't change the calculation of the individual volatility timeframes (30d, 60d, etc.) performed by calculateVolatilityWithTimeframe and stored via storeVolatility in prices.ts. Instead, it affects how these stored volatility values are consumed later, likely within the premium calculation logic (related to PCA-402). It might necessitate a new query function to retrieve and combine volatilities based on a given duration.
VCE-230: Implement Parkinson's volatility calculation method (using high/low if available)
What it is: This task requires implementing an alternative volatility calculation method, known as Parkinson's number or High-Low Volatility. It specifically uses the high and low prices of an asset during a period, which can sometimes capture volatility information missed by only using closing prices.
Relation to prices.ts: This would require adding a new calculation function within prices.ts. The current calculateVolatilityWithTimeframe uses only the price (closing price) field from the historicalPrices table. The new function would need to query the high and low fields as well (which are now populated by the primary CryptoCompare data fetch). The calculateAndStoreAllVolatilities function might need to be updated to call this new Parkinson's calculation, and storeVolatility would need to store the result, likely differentiating it using the calculationMethod field (e.g., calculationMethod: "parkinson").
VCE-231: Implement EWMA volatility calculation method
What it is: Exponentially Weighted Moving Average (EWMA) volatility is another method that gives more weight to recent price movements, assuming they are more relevant for predicting future volatility than older movements.
Relation to prices.ts: Similar to Parkinson's, this requires adding another distinct calculation function to prices.ts. This function would process the historical closing prices (price field) using the EWMA formula. Again, calculateAndStoreAllVolatilities would need to orchestrate calling this, and storeVolatility would save the result, tagged appropriately (e.g., calculationMethod: "ewma").
VCE-232: Design strategy for selecting/combining volatility methods based on context
What it is: This is a higher-level design task. Once you have multiple volatility calculation methods (standard deviation, Parkinson's, EWMA), you need a strategy to decide which one(s) to use or how to combine them. Should the system always calculate all three? Should it choose one based on data availability (e.g., use Parkinson's only if high/low data is present)? Should it produce a blended volatility metric?
Relation to prices.ts: The implementation of this strategy would likely live within calculateAndStoreAllVolatilities. It would dictate which calculation functions (standard, Parkinson's, EWMA) are called and potentially how their results are combined or prioritized before being stored via storeVolatility. It might also influence the schema of historicalVolatility if combined metrics are stored.
Impact of Libraries (Danfo.js, NumJs, Math.js - VCE-220, 221, 222):
The current volatility calculation in prices.ts uses standard JavaScript Math functions and array methods. Let's assess the potential improvement from the suggested libraries:
Math.js (VCE-222):
Benefit: Provides a comprehensive set of mathematical functions, potentially more robust or optimized than native Math for certain operations (like standard deviation, matrix operations if needed later). It's already planned for the Black-Scholes implementation (PCA-401), so using it for volatility calculations could promote consistency and code reuse. It can handle complex numbers, units, and matrix operations, which might be useful for future, more advanced financial modelling.
Significance: Likely a moderate improvement. It standardizes mathematical operations and might offer slightly cleaner syntax or better handling of edge cases compared to purely native JS implementations.
Danfo.js (VCE-220):
Benefit: Brings DataFrame and Series structures, similar to Python's Pandas. This can significantly simplify time-series manipulations, rolling calculations (like EWMA), data alignment, and potentially filtering or grouping operations compared to manual loops in JS. Implementing EWMA or more complex statistical analysis over the time series data could become much more concise and potentially less error-prone.
Significance: Could be a significant improvement if the volatility calculations become substantially more complex (e.g., implementing GARCH models, complex multi-factor models, or needing sophisticated time-series manipulations). For the currently planned methods (Standard Deviation, Parkinson's, EWMA), the benefit might be more about code clarity and conciseness rather than raw performance or feasibility, especially considering the potential overhead.
NumJs (VCE-221):
Benefit: Offers NumPy-like array operations, potentially faster for numerical computations on large arrays than native JS loops.
Significance: Likely low to moderate improvement. Its core functionality overlaps significantly with Math.js and potentially Danfo.js. If Math.js is adopted for general math and statistics, and Danfo.js for time-series/DataFrame operations, the specific niche for NumJs might be small unless very specific, performance-critical array manipulations are needed that the other two don't cover well.
Recommendation on Libraries:
Adopt Math.js: Since it's already needed for Black-Scholes, using it for volatility calculations makes sense for consistency and leveraging its robust functions. Implement the standard deviation, Parkinson's, and EWMA methods using native JS array methods combined with Math.js functions.
Evaluate Danfo.js Pragmatically: Assess the complexity after implementing the core logic with Math.js. If the implementation of EWMA or the strategy for combining methods (VCE-232) becomes overly complex with native loops/reductions, then introducing Danfo.js could be justified for improved maintainability and clarity. However, be mindful of its potential overhead within the Convex environment (bundle size, execution time).
Hold off on NumJs: Unless a specific need arises that isn't well-addressed by Math.js or potentially Danfo.js, adding NumJs seems unnecessary complexity.
In summary, the new VCE tasks introduce alternative volatility calculation methods and logic for using them contextually. Implementing them will primarily involve adding new functions to convex/prices.ts. Using Math.js offers moderate benefits, while Danfo.js could offer significant benefits for more complex scenarios but should be evaluated carefully against its overhead.
